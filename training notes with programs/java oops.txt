Object Oriented Programming: Java
=================================

Classes and Packages
	- Classification of Variables
	- Working with methods
Working with Object
	- Heap & Stack
Inheritance
	- Signature
	- Overriding
	- Overloading
	- Polymorphism
Keywords
	- final 
	- abstract 
	- static 	
Interface


Classes and Packages
--------------------
1. Access specifiers of a class

- public : can be accessed from within all packages
- default : can be accessed only within same package

2. Access specifiers of a method

- public 
- protected
- default
- private

3. Structure of a class

class is made of 2 entities:
a. variables
b. methods 

Variables
---------
- classified into 2 types 
a. instance variables
b. local variables

Instance v/s Local
------------------
1. 
 public class A {
	 int x;  //instance variable - inside class body
	 
	 public void display() {
		int y; //local variable - inside method body
	}
}

2. 
If Programmer does not initialize instance variable, JVM will initialize it and give a default value. 
However, if a programmer does not initialiaze local variable, JVM will also not initialize it. 
But if that variable is used without initilializing, JVM will give ERROR/Compilation Failure(CF)

ex.
 public class A {
	 int x;  //int x=0 
	 float f;//float f=0.0
	 
	 public void display() {
		int y; //y has no value
		System.out.println(y); //CF
	}
} 

3. Scope of Instance variables is in entire class whereas scope of local variables is in the method in which it is declared. 

ex.
 public class A {
	 int x=5;  //instance 
	 
	public void display() {
		 int y=6;
		 System.out.println(x); //5
	}
	 
	public void m1() {
		System.out.println(x); //5
		System.out.println(y); //ERROR/CF
	}
}

4. Instance variables go in the heap where as local variables are saved on the stack. 

5. when there is a name clash between local and instance variables, JVM prefers local variable. 

ex. 
 public class A {
	 int x=5;  //instance
	 
	public void display() {
		int x=10;  //local
		System.out.println(x); //10
		System.out.println(this.x);//5
	}
}

Note: use 'this' to access instance variables. 

Working with Objects: Heap and Stack
====================================
A a=new A(); 

- Reference goes on the stack, and object goes on the heap.


A a: Reference variable
new A() : Object 
 

Example: 
--------
App.java
=========
package com.main;

import com.beans.Customer;
import com.service.CustomerService;

public class App {
	public static void main(String[] args) {
		Customer c1 = new Customer(); 
		c1.setName("harry potter");
		c1.setBalance(10000); 
		
		Customer c2 = new Customer();
		c2.setName("ronald weasley");
		c2.setBalance(8000);
		
		CustomerService service = new CustomerService();
		service.deposit(c1, 5000);
		
		System.out.println(c1.getBalance()); //15000
		
		service.deposit(c2, 3000);
		
		System.out.println(c2.getBalance()); //11000
	}
}

Customer.java
=============
package com.beans;

public class Customer {
	private String name; 
	private double balance;
	
	public void setName(String name) {
		this.name = name;	
	}

	public void setBalance(double balance) {
		this.balance=balance;	
	}

	public double getBalance() {
		return this.balance;
	}
	
	
}
CustomerService.java
====================
package com.service;

import com.beans.Customer;

public class CustomerService {

	public void deposit(Customer c, int amount) {
		c.setBalance(c.getBalance() + amount); 	
	}

}

Inheritance
===========
- Signature
- Overriding 
- Overloading
- Polymorphism 

Signature of a method is calculated using following parameters
1. Name of the method
2. Number of Arguments 
3. Data type of Arguments
4. Sequence of Data types 

ex. 
public void m1(int x){ }
public void m1(int y){ }

-> Signature is Same 

ex. 
m1(int x,int y)
m1(int y,int x)

-> Signature is Same 

ex. 
m1(int x,float y)
m1(float x,int y)

-> Signature is different 


Overriding of method
====================
A method is considered to be Overrided if, 
a. The signature of the method is same in the sub-class &
b. Following 2 rules are followed
	1. Return type of the method is same
	2. The sub-class method should not have weaker access privilege 

Note: If any of above 2 rules(1,2) are violated and if the signature is same, then its CF. 

Overloading of Method
=====================
If the signature of the methods is different but names are same then it is overloaded method. 

Note: In Overloading you do not worry about return type or access privilege. 

ex 1. 
public void m1(int x)
public void m1(int y)
: Overriding 

method privilege: 
- public 
- protected
- default
- private

ex 2.
protected void m1(int x,int y)
public void m1(int y,int x)
: Overriding

ex 3.
protected void m1(int x,int y)
void m1(int y,int x)
: CF

ex 4.
void m1(int x,int y)
int m1(int y,int x)
: CF

ex 5.
void m1(int x,int y)
int m1(int y,float x)
: Overloding

ex 6. 
public void m1(float y)
public String m1(int x)
: overloading

ex 7. 
public void m1(int y)
public String m1(int x)
: cf


example: 

package com.main;

public class App {
	public static void main(String[] args) {
		 B b=new B();
		 b.m1();
		 b.m1(3);
	}
}

class A{ //super
	 public void m1() {
		System.out.println("m1 in A");
	}
}

class B extends A{ //sub
	protected void m1(int x) {
		System.out.println("m1 with Args in B");
		
	}
}

Polymorphism
============
: Multiple forms of an Object 

-> Syntax
-> method called polymorphically

Syntax:
------
public class App {
	public static void main(String[] args) {
		 A a=new A(); //pure object of A
		 B b=new B(); //pure object of B
		 
		 /*
		  * super-class ref = sub-class obj
		  */
		 
		 A a1 = new B(); //polymorphism 
		 
		 B b1 = new A(); //CF -- must be super=sub not the other way round
	}
}

class A{ //super
	
}
class B extends A{ //sub
	
}

method called from a polymorphic object
---------------------------------------
if a method is called from a polymorphic object, we follow a 2 step procedure

Step 1
------
go to super class and check if the method is present

if(persent)
	go to step 2
else
	CF

Step 2
------
come to sub-class and check if the method is overrided? 

if(overrided)
	call the overridded(sub-class) version
else
	call the super class version

Example:
public class App {
	public static void main(String[] args) {
		 A a=new A();
		 a.display(); //display in A
		 B b=new B();
		 b.display(); //display in B
		 
		 A polyobj=new B(); //poly 
		 polyobj.display(); //display in B
		 
		 polyobj.m1();//m1 in A
		 
		// polyobj.m2(); //CF : m2 not in A
	}
}

class A{ //super
	public void display() {
		System.out.println("display in A");
	}
	
	public void m1() {
		System.out.println("m1 in A");
	}
}

class B extends A{ //sub
	public void display() {
		System.out.println("display in B");
	}
	
	public void m2() {
		System.out.println("m2 in B");
	}
}

Keywords
========
- final : class, method, variable 
- static : method, variable
- abstract : class, method

final keyword
-------------
final class
-----------
If a class is marked as final,It cannot be extended. 

ex.
public class App {
	public static void main(String[] args) {
		A a=new A();
		a.m1();
	}
}

final class A{ //stand alone class 
	public void m1() {
		System.out.println("A");
	}
}

class B extends A{ // CF. A is final cannot be extended
	
}

final method
------------
if a method is marked as final, it cannot be overrided. 

ex.
public class App {
	public static void main(String[] args) {
		 B b=new B();
		 b.m1();
	}
}

class A{
	public final void m1() {
		System.out.println("m1 in A");
	}
	public void m2() {
		System.out.println("m2 in A");
	}
}

class B extends A{
	/*
	public void m1() { //CF. cannot override final method
		System.out.println("m1 in B");
	}
	*/
}


final variable
- If a variable is marked as final, it must be initialized by the programmer. 
- final variables cannot be assigned a value.

ex.
class A{
	int x; //0(JVM)
	final int y; //CF. final variable must be initialized by the programmer
	final int z=5; 
	
	void m1() {
		z=5; //CF. The final field A.z cannot be assigned
	}
	
	void m2(final int x,final int y) {
		
	}
}

abstract keyword
================
abstract method
---------------
- abstract method does not have a body and ends with a semi colon

public abstract void m1();

- abstract method can only be present in an abstract class

ex. 
abstract class A{
	public abstract void m1();
	
	public void m2() {
		System.out.println("m2 in A");
	}
}

abstract class
--------------
- abstract class cannot be instantiated. cannot create an object of an abstract class.

A a=new A(); //CF.  

- If a class extends an abstract class, it has to compulsarily override all the abstract methods of the super class. 

Note: if a sub-class does not wish to override any of the abstract methods of the super-class then it must mark itself as abstract. 

ex. 
public class App {
	public static void main(String[] args) {
		//A a=new A(); //CF> cannot create an object of an abstract class
		A a=new B(); 
		a.m1();
		a.m2();
	}
} 

abstract class A{
	public abstract void m1();
	
	public void m2() {
		System.out.println("m2 in A");
	}
}

class B extends A{
	// B must override m1() 
	public void m1(){
		System.out.println("m1 in B");
	}
}


Case Study
----------
You want to implement following methods having geometry calculations. 

- compute area of circle (pi * r ^2)
- compute area of rectangle (length * breadth)
- circumference of the circle (2 * pi * r)


static keyword
==============
static method
-------------
- If a programmer marks the method as static, it cannot be overrided by the sub class. However, if the subclass marks its own method as static, it can create its own version of that method. 

example:

public class App {
	public static void main(String[] args) {
		 A a=new B();
		 a.display();
	}
} 

class A{ //super
	public static void display() { //final & static
		System.out.println("display in A");
	}
	
	public void m1() {
		System.out.println("m1");
	}
}

class B extends A{ //sub-class
	public static void display(){
		System.out.println("display in B");
	}
}

- static method can be called in 3 possible ways. 
	- using an Object 
	- using class-name (preferred way-static way)
	- directly(not at all preferred)

ex.
---
public class Person {
	public static void personInfo() {
		System.out.println("I am a person");
	}
	
	public void m1() {
		System.out.println("m1 in person");
	}
}


package com.main;

import com.service.Person;
 
import static com.service.Person.personInfo;
 public class App {
	public static void main(String[] args) {
		 /* calling a static method */
		
		//Option 1 : using object
		Person person = new Person();
		person.personInfo();
		person.m1();
		
		//Option 2 : static way
		Person.personInfo();
		
		//Option 3: directly
		personInfo();
	}
} 
 
static variable
---------------
- static variables are saved in static memory of the class

ex.
public class App {
	public static void main(String[] args) {
		A a1 = new A();
		A a2 = new A();
		
		a1.setX(10);
		a2.setX(12);
		
		System.out.println(a1.getX()); //10
		System.out.println(a2.getX()); //12
		
		A.setY(15);
		
		System.out.println(A.getY()); //15
		
		System.out.println(a1.getY());//15
		System.out.println(a2.getY());//15
	}
}

class A {
	private int x;
	private static int y;

	public int getX() {
		return x;
	}

	public void setX(int x) {
		this.x = x;
	}

	public static int getY() {
		return y;
	}

	public static void setY(int y) {
		A.y = y;
	}

}

Example 2: 


import com.beans.Customer;

public class App {
	public static void main(String[] args) {
		Customer c1=new Customer(); 
		Customer c2=new Customer(); 
		
		c1.setName("harry potter");
		c1.setBalance(10000);
		
		c2.setName("ronald weasley");
		c2.setBalance(8000);
		
		Customer.setRateOfInterest(4.0);
		
		System.out.println(c1.getRateOfInterest());
		System.out.println(c2.getRateOfInterest());
		System.out.println(Customer.getRateOfInterest());
	}
}

 
Customer.java
-------------
package com.beans;

public class Customer { //C1 C2 C3
	private String name;
	private double balance;
	private static double rateOfInterest;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getBalance() {
		return balance;
	}
	public void setBalance(double balance) {
		this.balance = balance;
	}
	public static double getRateOfInterest() {
		return rateOfInterest;
	}
	public static void setRateOfInterest(double rateOfInterest) {
		Customer.rateOfInterest = rateOfInterest;
	}  
}

Interface
=========
Rule 1:
-------
An interface in java, by default, is an abstract entity and hence can not instantiated. 

public interface Inter { 
//public interface abstract Inter{}

}

Inter i =new Inter(); //CF 

Rule 2
------
A variable in interface, by default, is public static and final. 

public interface Inter { 	
int x;  //public static final int x; 
//CF. x must be initialized
	int y=6;
}

Rule 3
------
A method in interface, by default, is public and abstract. 

public interface Inter { 
	 void m1();   //public abstract void m1();
	 public abstract void m2(); 
}

Rule 4
------
An Interface can extend other interface

public interface Inter { 
	  void m1(); 
}

interface Inter1 extends Inter{
	//Inter 1 has m1() from Inter
}

Rule 5: 
------
A class implements and interface and must override all the methods of that interface 

ex.
public interface Inter { 
	public abstract  void m1(); 
}

class A implements Inter{

	@Override
	public void m1() {
		System.out.println("m1 in A");
		
	}
	
}

Note: If a class does not wish to override any of the interface methods, then we must mark the class as abstract. 


ex. 
package com.main;

public interface Inter { 
	public abstract  void m1(); 
	void m2(); 
}

abstract class A implements Inter{

	@Override
	public void m1() {
		System.out.println("m1 in A");	
	}
}

class B extends A{

	@Override
	public void m2() {
		System.out.println("m2 in B");	
	}
}

App.java
--------
package com.main;

public class App {
	public static void main(String[] args) {
		 B b=new B();
		 b.m1();
		 b.m2();
	}
}

Case Study
==========
Implement deposit and withdrawal operations for a bank for multiple customers.
Also calculate interest payable to each customer. 

refer. project code. 

 








